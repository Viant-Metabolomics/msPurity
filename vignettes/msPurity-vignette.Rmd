---
title: "Using msPurity for Automated Evaluation of Precursor Ion Purity for Mass Spectrometry Based Fragmentation in Metabolomics"
author: "Thomas N. Lawson"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 3  
    number_sections: true  
    toc_float: true
  
bibliography: mspurity.bib
vignette: >
  %\VignetteIndexEntry{msPurity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Assessing precursor ion purity (and general functionality)

## Introduction

Th R was originally developed to assess the contribution of the targeted precursor in a fragmentation isolation window using a metric called "precursor ion purity". See associated paper  [@Lawson2017].

What we call "Precursor ion purity"" is a measure of the contribution of a selected precursor peak in an isolation window used for fragmentation. The simple calculation involves dividing the intensity of the selected precursor peak by the total intensity of the isolation window. When assessing MS/MS spectra this calculation is done before and after the MS/MS scan of interest and the purity is interpolated at the time of the MS/MS acquisition. The calculation is  similar to the "Precursor Ion Fraction"" (PIF) metric described by [@Michalski2011] for proteomics with the exception that purity here is interpolated at the recorded point of MS2 acquisition using bordering full-scan spectra. Additionally, low abundance ions that are remove that are thought to have limited contribution to the resulting MS2 spectra and the isolation efficiency of the mass spectrometer can be used to normalise the contributing ions to metric.

The precursor ion purity can be calculated in two use cases
1.  Assessing precursor purity of previously acquired MS2 spectra: A user has acquired either LC-MS2 or DIMS2 spectra and an assessment is made of the precursor purity for each MS2 scan. purityA
2. Assessing precursor purity of anticipated isolation windows for MS2 spectra: A user has acquired either LC-MS (purityX) or DIMS (purityD) full scan (MS1) data and an assessment is to be made of the precursor purity of detected features using anticipated or theoretical isolation windows. This information can then be used to guide further targeted MS2 experiments.
The package has been developed to be used with DI-MS or LC-MS data and has been checked to work with the following vendor files after conversion to mzML: Thermo, Agilent and AB Sciex.


## Assessing precursor purity of previously acquired MS2 spectra

### purityA 

#### General

Given a vector of LC-MS/MS or DI-MS/MS mzML file paths the precursor ion purity of each MS/MS scan can be calculated and stored in the purityA S4 class object where a dataframe of the purity results can be accessed using the appropriate slot (`pa@puritydf`).

The calculation involves dividing the intensity of the selected precursor peak by the total intensity of the isolation window and is performed before and after the MS2 scan of interest and interpolated at the recorded time of the MS2 acquisition.

Additionally, isotopic peaks can estimated and omitted from the calculation, low abundance peaks are removed that are thought to have limited contribution to the resulting MS2 spectra and the isolation efficiency of the mass spectrometer can be used to normalise the intensities used for the calculation.

The purity dataframe (`pa@puritydf`) consists of the following columns:

* __pid__: unique id for MS/MS scan
* __fileid__: unique id for file
* __seqNum__: scan number
* __precursorIntensity__: precursor intensity value as defined from mzML file
* __precursorMZ__: precursor m/z value as defined from mzML file
* __precursorRT__: precursor RT value as defined from mzML file
* __precursorScanNum__: precursor scan number value as defined from mzML file
* __id__: unique id (redundant)
* __filename__: mzML filename
* __precursorNearest__: MS1 scan nearest to this MS/MS scan
* __aMz__: The m/z value in the precursorNearest scan which most closely matches the precursorMZ value provided from the mzML file
* __aPurity__: The purity score for __aMz__
* __apkNm__: The number of peaks in the isolation window for __aMz__
* __iMz__: The m/z value in the precursorNearest scan that is the most intense within the isolation window.
* __iPurity__: The purity score for __iMz__
* __ipkNm__: The number of peaks in the isolation window for __iMz__
* __inPurity__: The interpolated purity score
* __inpkNm__: The interpolated number of peaks in the isolation window

The remaining slots for purityA class include
* __@cores__: The number of CPUs to be used for any further processing with this purityA object
* __@fileList__: list of the files that have been processed
* __@mzRback__: The backend library used by mzR to extract information from the mzML file (e.g. pwiz)
* __@grped_df__: If frag4feature has been performed, a dataframe of the grouped XCMS features linked to the associated fragmentation spectra precursor * details is recorded here
* __@grped_ms2__:  If frag4feature has been performed, a list of fragmentation spectra assoicated with each grouped XCMS feature is recorded here
* __@f4f_link_type__: If frag4feature has been performed, the linking method is recorded here
* __@av_spectra__: if averageIntraFragSpectra, averageInterFragSpectra,  or averageAllFragSpectra have been performed, the average spectra is recorded here
* __@av_intra_params__:  If averageIntraFragSpectra has been performed, the parameters are recorded here
* __@av_inter_params__: if averageInterFragSpectra has been performed, the  parameters are recorded here
* __@av_all_params__: If averageAllFragSpectra has been performed, the parameters are recorded here
* __@db_path__: If create_database has been performed, the resulting database path is recorded here




```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
library(msPurity)
msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
msPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "LCMS_")
```

```{r}
pa <- purityA(msmsPths)
print(pa@puritydf[1:3,])
```

#### Isolation efficiency

We define here "isolation efficiency"" as the effect of the position of an ion within an isolation window on its relative intensity in corresponding fragmentation spectra. When the isolation efficiency of an instrument is known, the peak intensities within an isolation window can be normalised for the precursor purity calculation. In the example in figure 2, an R-Cosine isolation efficiency curve is used, the red peak (the targeted precursor ion peak) would not change following normalisation -  as the contribution is at 1 (i.e. 100%) - however the the black peak (a contaminating ion) would be normalised by approximately 0.1 (i.e. 10%) and the normalised intensity would be calculated as 1000 (i.e. original intensity of 10000 x 0.1)

The isolation efficiency can be estimated by looking at a single precursor with a sliding window. See figure 3 from the msPurity paper. This has been performed for a Thermo Fisher Q-Exactive Mass spectrometer using 0.5 Da windows and can be set within msPurity by using msPurity::iwNormQE.5() as the input to the iwNormFunc argument. 

Other available options are to use gaussian isolation window msPurity::iwNormGauss(minOff=-0.5, maxOff = 0.5) or a R-Cosine window msPurity::iwNormRCosine(minOff=-0.5, maxOff=0.5). Where the minOff and maxOff can be changed depending on the isolation window. 

A user can also create their own normalisation function. The only requirement of the function is that given a value between the minOff and maxOff a normalisation value between 0-1 is returned.

Se below for example of using one of the default provided normalisation functions. 

```{r}
pa <- purityA(msmsPths, iwNorm=TRUE, iwNormFun=iwNormGauss(-0.5, 0.5))
```

If the isolation efficiency of the instrument is not known, by default iwNorm is set to FALSE and no normalisation will occur.


## Mapping XCMS features to fragmentation spectra
The MS/MS spectra can be assigned to an XCMS grouped feature using the `frag4feature` function. 

First an xcmsSet object of the same files is required
```{r results='hide', message=FALSE, warning=FALSE,  echo = T}

suppressPackageStartupMessages(library(xcms))

xset <- xcms::xcmsSet(msmsPths)
xset <- xcms::group(xset)
xset <- xcms::retcor(xset)
xset <- xcms::group(xset)
```

```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
pa <- frag4feature(pa, xset)
```

The slot `grped_df` is a dataframe of the grouped XCMS features linked to a reference to any associated MS/MS scans in the region of the full width of the XCMS feature in each file. The dataframe contains the following columns.

* __grpid__: XCMS grouped feature id
* __mz__: derived from XCMS peaklist
* __mzmin__: derived from XCMS peaklist
* __mzmax__: derived from XCMS peaklist
* __rt__: derived from XCMS peaklist
* __rtmin__: derived from XCMS peaklist
* __rtmax__: derived from XCMS peaklist 
* __into__: derived from XCMS peaklist
* __intb__: derived from XCMS peaklist
* __maxo__: derived from XCMS peaklist
* __sn__: derived from XCMS peaklist
* __sample__: derived from XCMS peaklist
* __id__: unique id of MS/MS scan
* __precurMtchID__: Associated nearest precursor scan id (file specific)
* __precurMtchRT__: Associated precursor scan RT
* __precurMtchMZ__: Associated precursor _m/z_
* __precurMtchPPM__: Associated precursor _m/z_ parts per million (ppm) tolerance to XCMS feauture _m/z_
* __inPurity__: The interpolated purity score

```{r}
print(head(pa@grped_df[1:3]))
```


The slot `grped_ms2` is a list of the associated fragmentation spectra for the grouped features. 

```{r}
print(pa@grped_ms2[2])
```

# Assessing precursor purity of anticipated isolation windows for MS2 spectra

## purityX: Assessing anticipated purity of XCMS features from an LC-MS run

NOTE ON TERMINOLOGY: The term 'anticipated purity' and 'predicted purity' are used interchangeably

A processed xcmsSet object is required to determine the anticipated (predicted) precursor purity score from an LC-MS dataset. The offsets chosen in the parameters should reflect what settings would be used in a hypothetical fragmentation experiment.

The slot `predictions` provides the anticipated (predicted) purity scores for each feature. The dataframe contains the following columns:

* __grpid__: XCMS grouped feature id
* __mean__: Mean predicted purity of the feature
* __median__: Median predicted purity of the feature
* __sd__: Standard deviation of the predicted purity of the feature
* __stde__: Standard error of the predicted purity of the feature
* __pknm__: Median peak number in isolation window
* __RSD__: Relative standard deviation of the predicted purity of the feature
* __i__: Median intensity of the grouped feature. Uses XCMS "into" intensity value.
* __mz__: _m/z_ of the XCMS grouped feature

_XCMS run on an LC-MS dataset_
```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
xset <- xcms::xcmsSet(msPths)
xset <- xcms::group(xset)
xset <- xcms::retcor(xset)
xset <- xcms::group(xset)
```

_Perform purity calculations_
```{r}
ppLCMS <- purityX(xset, offsets=c(0.5, 0.5), xgroups = c(1, 2))

print(ppLCMS@predictions[1:3,])
```


## purityD: Assessing anticipated purity from a DI-MS run

The anticipated/predicted purity for a DI-MS experiment can be performed on any DI-MS dataset consisting of multiple MS1 scans of the same mass range, i.e. it has **not** been developed to be used with any SIM stitching approach.

A number of simple data processing steps are performed on the mzML files to provide a DI-MS peak list (features) to perform the purity predictions on. 

These data processing steps consist of:

* Averaging peaks across multiple scans 
* Removing peaks below a signal to noise threshold [optional]
* Removing peaks less than an intensity threshold [optional]
* Removing peaks above a RSD threshold for intensity [optional]
* Where there is a blank, subtracting blank peaks [optional]

The averaged peaks before and after filtering are stored in the `avPeaks` slot of purityPD S4 object.


__Get file dataframe__:
The purityD constructor requires a dataframe consisting of the following columns:

* filepth
* name
* sampleType [either sample or blank]
* class [for grouping samples together]
* polarity [optional]

```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
datapth <- system.file("extdata", "dims", "mzML", package="msPurityData")
inDF <- Getfiles(datapth, pattern=".mzML", check = FALSE)
ppDIMS <- purityD(inDF, mzML=TRUE)
```

__Average spectra__:
The default averaging will use a Hierarchal clustering approach. Noise filtering is also performed here.

```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
ppDIMS <- averageSpectra(ppDIMS, snMeth = "median", snthr = 5)
```

__Filter by RSD and Intensity__
```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
ppDIMS <- filterp(ppDIMS, thr=5000, rsd = 10)
```

__Subtract blank__
```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
ppDIMS <- subtract(ppDIMS)
```

__Predict purity__
```{r}
ppDIMS <- dimsPredictPurity(ppDIMS)

print(head(ppDIMS@avPeaks$processed$B02_Daph_TEST_pos))
```


## Calculating the anticipated (predicted) purity from a known _m/z_ target list for DI-MS

The data processing steps carried out through purityPD can be bypassed if the peaks (_m/z_ values) of interest are already known. The function `dimsPredictPuritySingle()` can be used to predict the purity of a list of _m/z_ values in a chosen mzML file.

```{r results='hide', message=FALSE, warning=FALSE,  echo = TRUE}
mzpth <- system.file("extdata", "dims", "mzML", "B02_Daph_TEST_pos.mzML", package="msPurityData")
predicted <- dimsPredictPuritySingle(filepth = mzpth, mztargets = c(111.0436, 113.1069))
print(predicted)
```

# References

