% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/purityA-av-spectra.R
\docType{methods}
\name{averageInterFragSpectra,purityA-method}
\alias{averageInterFragSpectra,purityA-method}
\alias{averageInterFragSpectra}
\title{Using a purityA object, average and filter fragmentation spectra for each XCMS feature across multiple MS data files}
\usage{
\S4method{averageInterFragSpectra}{purityA}(pa, minfrac = 0.5,
  minnum = 1, ppm = 5, snr = 0, ra = 0, av = "median",
  sumi = TRUE, rmp = FALSE, cores = 1)
}
\arguments{
\item{pa}{object; purityA object}

\item{minfrac}{numeric; minimum ratio of the peak fraction (peak count / total peaks) across files}

\item{minnum}{numeric; minimum number of times peak is present across fragmentation spectra across files}

\item{ppm}{numeric; ppm threshold to average across files}

\item{snr}{numeric; minimum signal-to-noise of the peak across files}

\item{ra}{numeric; minimum relative abundance of the peak across files}

\item{av}{character; type of averaging to use (median or mean)}

\item{sumi}{boolean; TRUE if the intensity for each peak is summed across averaged spectra}

\item{rmp}{boolean; TRUE if peaks are to be removed that do not meet the threshold criteria. Otherwise they will just be flagged}

\item{cores}{numeric; Number of cores for multiprocessing}
}
\description{
**General**

Average and filter fragmentation spectra for each XCMS feature across MS data files. This can only be run after averageIntraFragSpectra has been used.

The averaging is performed using hierarchical clustering of the m/z values of each peaks, where m/z values within a set ppm tolerance will be clustered. The clustered peaks are then averaged (or summed).

The fragmentation can be filtered on the averaged spectra (with the arguments snr, rsd, minfrac and ra)

The output is a purityA object with the following slots now with data

* @av_spectra: the average spectra is recorded here stored as a list. e.g. "pa@av_spectra$`1`$av_inter" would give the average spectra for grouped feature 1
* @av_intra_params: The parameters used are recorded here

Each spectra in the av_spectra list contains the following columns:
*
* cl: id of clustered (averaged) peak
* mz: average m/z
* i: average intensity
* snr: average signal to noise ratio
* rsd: relative standard deviation
* count: number of clustered peaks
* total: total number of potential scans to be used for averaging
* inPurity: average precursor ion purity
* ra: average relative abundance
* frac: the fraction of clustered peaks (e.g. the count/total)
* snr_pass_flag: TRUE if snr threshold criteria met
* minfrac_pass_flag: TRUE if minfrac threshold criteria
* ra_pass_flag: TRUE if ra threshold criteria met
* pass_flag: TRUE if all threshold criteria met

**Example LC-MS/MS processing workflow**

 * Purity assessments
   +  (mzML files) -> purityA -> (pa)
 * XCMS processing
   +  (mzML files) -> xcms.xcmsSet -> xcms.merge -> xcms.group -> xcms.retcor -> xcms.group -> (xset)
 * Fragmentation processing
   + (xset, pa) -> frag4feature -> filterFragSpectra -> averageIntraFragSpectra -> **averageIntraFragSpectra** -> createDatabase -> spectralMatching -> (sqlite spectral database)
}
\examples{

#msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
#xset <- xcms::xcmsSet(msmsPths, nSlaves = 1)
#xset <- xcms::group(xset)
#xset <- xcms::retcor(xset)
#xset <- xcms::group(xset)

#pa  <- purityA(msmsPths, interpol = "linear")
#pa <- frag4feature(pa, xset)
#pa <- averageIntraFragSpectra(pa)
pa <- readRDS(system.file("extdata", "tests", "purityA", "4_averageIntraFragSpectra_no_filter_pa.rds", package="msPurity"))
pa <- averageInterFragSpectra(pa)

}
