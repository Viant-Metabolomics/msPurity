% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectralMatching.R
\name{spectralMatching}
\alias{spectralMatching}
\title{Spectral matching}
\usage{
spectralMatching(q_dbPth, l_dbPth = NA, q_purity = NA,
  q_ppmProd = 10, q_ppmPrec = 5, q_raThres = NA,
  q_pol = "positive", q_instrumentTypes = NA, q_instrument = NA,
  q_sources = NA, q_spectraTypes = "av_all", q_pids = NA,
  q_rtrange = c(NA, NA), q_spectraFilter = TRUE, q_xcmsGroups = NA,
  q_accessions = NA, l_purity = NA, l_ppmProd = 10, l_ppmPrec = 5,
  l_raThres = NA, l_pol = "positive", l_instrumentTypes = NA,
  l_instrument = NA, l_sources = NA, l_spectraTypes = NA,
  l_pids = NA, l_rtrange = c(NA, NA), l_spectraFilter = FALSE,
  l_xcmsGroups = NA, l_accessions = NA, usePrecursors = TRUE,
  raW = 0.5, mzW = 2, rttol = NA, cores = 1, updateDb = FALSE,
  copyDb = FALSE, outDir = ".")
}
\arguments{
\item{q_dbPth}{character; Path of the database of queries that will be searched against the library spectra. Generated from createDatabase}

\item{l_dbPth}{character; path to library spectral SQLite database. Defaults to msPurityData package data.}

\item{q_purity}{character; Precursor ion purity threshold for the query spectra}

\item{q_ppmProd}{numeric; ppm tolerance for query product}

\item{q_ppmPrec}{numeric; ppm tolerance for query precursor}

\item{q_raThres}{numeric; Relative abundance threshold for query spectra}

\item{q_pol}{character; Polarity of query spectra ['positive', 'negative', NA].}

\item{q_instrumentTypes}{vector; Instrument types for query spectra.}

\item{q_sources}{vector; Sources of query spectra (e.g. massbank, hmdb).}

\item{q_spectraTypes}{character; Spectra types of query spectra to perfrom spectral matching e.g. ('scans', 'av_all', 'intra', 'inter')}

\item{q_pids}{vector; pids for query spectra (correspond to column 'pid; in s_peak_meta)}

\item{q_rtrange}{vector; retention time range (in secs) of query spectra, first value mininum time and second value max e.g. c(0, 10) is between 0 and 10 seconds}

\item{q_spectraFilter}{boolean; For query spectra, if prior filtering performed with msPurity, flag peaks will be removed from spectral matching}

\item{q_xcmsGroups}{vector; XCMS group ids for query spectra}

\item{q_accessions}{vector; accession ids to filter query spectra}

\item{l_purity}{character; Precursor ion purity threshold for the library spectra (uses interpolated purity - inPurity)}

\item{l_ppmProd}{numeric; ppm tolerance for library product}

\item{l_ppmPrec}{numeric; ppm tolerance for library precursor}

\item{l_raThres}{numeric; Relative abundance threshold for library spectra}

\item{l_pol}{character; Polarity of library spectra ['positive', 'negative', NA].}

\item{l_instrumentTypes}{vector; Instrument types for library spectra.}

\item{l_sources}{vector; Sources of library spectra (e.g. massbank, hmdb).}

\item{l_spectraTypes}{vector; Spectra type of library spectra to perfrom spectral matching with e.g. ('scans', 'av_all', 'intra', 'inter')}

\item{l_pids}{vector; pids for library spectra (correspond to column 'pid; in s_peak_meta)}

\item{l_rtrange}{vector; retention time range (in secs) of library spectra, first value mininum time and second value max e.g. c(0, 10) is between 0 and 10 seconds}

\item{l_spectraFilter}{boolean; For library spectra, if prior filtering performed with msPurity, flag peaks will be removed from spectral matching}

\item{l_xcmsGroups}{vector; XCMS group ids for library spectra}

\item{l_accessions}{vector; accession ids to filter library spectra}

\item{usePrecursors}{boolean; If TRUE spectra will be filtered by similarity of precursors based on ppm range defined by l_ppmPrec and q_ppmPrec}

\item{raW}{numeric; Relative abundance weight for spectra (default to 0.5 as determined by massbank for ESI data)}

\item{mzW}{numeric; mz weight for spectra (default to 2 as determined by massbank for ESI data)}

\item{rttol}{numeric ; Tolerance in time range between the library and query spectra retention time}

\item{cores}{numeric; Number of cores to use}

\item{updateDb}{boolean; Update the Query SQLite database with the results}

\item{copyDb}{boolean; If updating the database - perform on a copy rather thatn the original query database}

\item{outDir}{character; If copying the database - the directory to copy the database to}

\item{q_instruments}{vector; Instruments for query spectra (note that this is used in combination with q_instrumentTypes - any
spectra matching either q_instrumentTypes or q_instruments will be used).}

\item{l_instruments}{vector; Instruments for library spectra (note that this is used in combination with q_instrumentTypes - any
spectra matching either q_instrumentTypes or q_instruments will be used).}
}
\value{
list of database details and dataframe summarising the results for the xcms features
}
\description{
Perform spectral matching to spectral libraries on SQLite database of query and library spectra
}
\examples{
#msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
#xset <- xcms::xcmsSet(msmsPths)
#xset <- xcms::group(xset)
#xset <- xcms::retcor(xset)
#xset <- xcms::group(xset)

#pa  <- purityA(msmsPths)
#pa <- frag4feature(pa, xset)
#pa <- filterFragSpectra(pa, allfrag=TRUE)
#pa <- averageAllFragSpectra(pa)
#q_dbPth <- createDatabase(pa, xset)
q_dbPth <- system.file("extdata", "createDatabase_example.sqlite", package="msPurity")
result <- spectralMatching(q_dbPth, q_xcmsGroups = c(12, 27), cores=1, l_accessions=c('CCMSLIB00000577898','CE000616'))

}
