% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/purityA-filter-frag-spectra.R
\docType{methods}
\name{filterFragSpectra,purityA-method}
\alias{filterFragSpectra,purityA-method}
\alias{filterFragSpectra}
\title{Filter fragmentations spectra associated with an XCMS feature}
\usage{
\S4method{filterFragSpectra}{purityA}(pa, ilim = 0, plim = 0.8,
  ra = 0, snr = 3, rmp = FALSE, snmeth = "median",
  allfrag = FALSE)
}
\arguments{
\item{pa}{object; purityA object}

\item{ilim}{numeric; min intensity of a peak}

\item{plim}{numeric; min precursor ion purity of the associated precursor for fragmentation spectra scan}

\item{ra}{numeric; minimum relative abundance of a peak}

\item{snr}{numeric; minimum signal-to-noise of a peak  peak within each file}

\item{rmp}{boolean; TRUE if peaks are to be removed that do not meet the threshold criteria. Otherwise they will just be flagged.}

\item{snmeth}{character; Method to calculate signal to noise ration (either median or mean)}

\item{allfrag}{boolean; Whether to filter on all fragmentation spectra or or just the fragmentation spectra grouped to XCMS feature}
}
\value{
purityA object with additional columns for the fragmentation spectra in the grped_msms slot
}
\description{
**General**
Flag and filter features based on signal-to-noise ratio, relative abundance, intensity threshold and precursor ion purity of precursor.

The pa@grped_msms spectra matrices are updated with the following columns

* snr: Signal to noise ratio (calculated at scan level)
* ra: Relative abundance (calculated at scan level)
* purity_pass_flag: Precursor ion purity flag (1 pass, 0 fail)
* intensity_pass_flag: Intensity flag (1 pass, 0 fail)
* snr_pass_flag: Signal-to-noise pass flag (1 pass, 0 fail)
* ra_pass_flag: Relative abundance pass flag (1 pass, 0 fail)
* pass_flag: Overall pass flag, all flags must pass for this to pass (1 pass, 0 fail)

**Example LC-MS/MS processing workflow**

The purityA object can be used for further processing including linking the fragmentation spectra to XCMS features, averaging fragmentation, database creation and spectral matching (from the created database). See below for an example workflow

 * Purity assessments
   +  (mzML files) -> purityA -> (pa)
 * XCMS processing
   +  (mzML files) -> xcms.xcmsSet -> xcms.merge -> xcms.group -> xcms.retcor -> xcms.group -> (xset)
 * Fragmentation processing
   + (xset, pa) -> frag4feature -> **filterFragSpectra** -> averageAllFragSpectra -> createDatabase -> spectralMatching -> (sqlite spectral database)
}
\examples{

#msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
#xset <- xcms::xcmsSet(msmsPths)
#xset <- xcms::group(xset)
#xset <- xcms::retcor(xset)
#xset <- xcms::group(xset)

#pa  <- purityA(msmsPths)
#pa <- frag4feature(pa, xset)
pa <- readRDS(system.file("extdata", "tests", "purityA", "2_frag4feature_pa.rds", package="msPurity"))
pa <- filterFragSpectra(pa)

}
