% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/purityA-av-spectra.R
\docType{methods}
\name{averageAllFragSpectra,purityA-method}
\alias{averageAllFragSpectra,purityA-method}
\alias{averageAllFragSpectra}
\title{Using a purityA object, average and filter MS/MS spectra for each XCMS feature within
and across MS data files (ignoring intra and inter relationships)}
\usage{
\S4method{averageAllFragSpectra}{purityA}(pa, minfrac = 0.5,
  minnum = 1, ppm = 5, snr = 0, ra = 0, av = "median",
  sumi = TRUE, rmp = FALSE, cores = 1)
}
\arguments{
\item{pa}{object; purityA object}

\item{minfrac}{numeric;minimum ratio of the peak fraction (peak count / total peaks) across all (ignoring intra and inter relationships)}

\item{minnum}{numeric; minimum number of times peak is present across all fragmentation spectra (ignoring intra and inter relationships)}

\item{ppm}{numeric; ppm threshold to average across all scans (ignoring intra and inter relationships)}

\item{snr}{numeric;  minimum signal-to-noise of the peak across all (ignoring intra and inter relationships)}

\item{ra}{numeric; minimum relative abundance of the peak fraction across all (ignoring intra and inter relationships)}

\item{av}{character; type of averaging to use (median or mean)}

\item{sumi}{boolean; TRUE if the intensity for each peak is summed across averaged spectra}

\item{rmp}{boolean; TRUE if peaks are to be removed that do not meet the threshold criteria. Otherwise they will just be flagged}

\item{cores}{numeric; Number of cores for multiprocessing}
}
\value{
Returns a purityA object (pa) with the following slots now with data

* pa@av_spectra: the average spectra is recorded here stored as a list. E.g. pa@av_spectra$`1`$av_all would give the average spectra for grouped feature 1.
* pa@av_all_params: The parameters used are recorded here

Each spectra in the av_spectra list contains the following columns:

* cl: id of clustered (averaged) peak
* mz: average m/z
* i: average intensity
* snr: average signal to noise ratio
* rsd: relative standard deviation
* count: number of clustered peaks
* total: total number of potential scans to be used for averaging
* inPurity: average precursor ion purity
* ra: average relative abundance
* frac: the fraction of clustered peaks (e.g. the count/total)
* snr_pass_flag: TRUE if snr threshold criteria met
* minfrac_pass_flag: TRUE if minfrac threshold criteria
* ra_pass_flag: TRUE if ra threshold criteria met
* pass_flag: TRUE if all threshold criteria met
}
\description{
**General**
Average and filter fragmentation spectra for each XCMS feature within and across MS data files (ignoring intra and inter relationships).

The averaging is performed using hierarchical clustering of the m/z values of each peaks, where m/z values within a set ppm tolerance will be clustered. The clustered peaks are then averaged (or summed).

The fragmentation can be filtered on the averaged spectra (with the arguments snr, rsd, minfrac, ra)

**Example LC-MS/MS processing workflow**

 * Purity assessments
   +  (mzML files) -> purityA -> (pa)
 * XCMS processing
   +  (mzML files) -> xcms.xcmsSet -> xcms.merge -> xcms.group -> xcms.retcor -> xcms.group -> (xset)
 * Fragmentation processing
   + (xset, pa) -> frag4feature -> filterFragSpectra -> **averageAllFragSpectra** -> createDatabase -> spectralMatching -> (sqlite spectral database)
}
\examples{

#msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
#xset <- xcms::xcmsSet(msmsPths, nSlaves = 1)
#xset <- xcms::group(xset)
#xset <- xcms::retcor(xset)
#xset <- xcms::group(xset)

#pa  <- purityA(msmsPths, interpol = "linear")
#pa <- frag4feature(pa, xset)
#pa <- filterFragSpectra(pa)
pa <- readRDS(system.file("extdata", "tests", "purityA", "3_filterFragSpectra_pa.rds", package="msPurity"))
pa <- averageAllFragSpectra(pa)

}
